---
title: Approach and Implementation
---

# Why CodeMeta tools?

Over the last several years I've folded in the codemeta.json file as a data source for building and releasing software for Caltech Library. Initially I used a tool I wrote called "codemeta2cff" but over time I started to use the CodeMeta data to also generate version files for Go, Python, JavaScript and more recently TypeScript projects. I've also integrated things like the Git repository hash and compile dates. I also have used the codemeta.json file to populate about pages for project websites. Rather than continuing with a bunch of ad-hoc scripts and Pandoc templates it makes sense to consolidate these practices into a simple command line program that can be used as part of a standard build and release processes used by the Caltech Library development team.

So why is this significant?  The metadata held in our CodeMeta JSON file is very helpful when integrating into software repositories like [CaltechDATA](https://data.caltech.edu). While my initial focus in adopting CodeMeta was documentation for my projects I think it can play a common role across projects regardless of implementation language.  On the command line this means you can easily have a consistent "version" response indicating not just the semver and program name but also the Git hash and compile date. This is important for support reasons. As we evolve programs that are deployed on individual computers users often don't update their software. Knowing that they are running a different version than the currently supported one can cut down the time needed to diagnosis issues. Similarly if we introduce a regression in a new version we can check to see if the fix got applied because the Git hash in the version string will change on each commit. For server software having consistent version info serves a similar role.

# What problem are we solving with CM Tools?

The following files are common in my projects and other's projects at Caltech Library.

- CITATION.cff
- about.md
- version.go, version.py, version.js, version.ts
- page templates for the project website

Having a CM Tool that can generate these means the build processes can be simplified and can more easily translate across the POSIX and Windows divide. 

The common files that can use the information in the CodeMeta file are likely to grow over time. The implementation of CM Tools should make it easy to add additional transformations as needed.

Right now my build processes require Pandoc. Pandoc isn't something that most developers think about as part of their build tool chain outside of building websites.  With an easy to install command line tool the Pandoc dependency can be removed.

# Implementation

CM Tools is implemented as a [TypeScript](https://typescriptlang.org) program compiled using [Deno](https://deno.com). TypeScript was chosen because it is a superset of JavaScript which is one of the most common programming languages in the early 21st century.  Deno provide easy cross platform compilation for our supported operating systems -- macOS, Windows and Linux. Deno and TypeScript together provide many of the advantages of our Go based utilities with the advantage of a large part of the Library, Archives and Museum developer communities that could potentially contribute.

The architecture of CM Tools is a series of small TypeScript files

codemeta.ts
: provides the basic CodeMeta 3 object.

gitcmds.ts
: provides a thin wrapper around the Git command for retrieving Git hash values

helptext.ts
: provides the help documentation use to generate man pages and website doc pages

version.ts
: This is generated by CM Tools' `cmt` command and holds the version info for CM Tools

person_or_organization.ts
: This holds the agent model for people and organizations used in the CodeMeta object

transform.ts
: This does the heavy lifting and transforming the CodeMeta 3 object into our target files.

cmt.ts
: This is the TypeScript that provides our command line interface for CM Tools
